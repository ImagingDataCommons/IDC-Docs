# IDC API Concepts

The IDC API is based on IDC Data Model concepts. Several of these concepts have been previously introduced in the context of the IDC Portal. We discuss these concepts here with respect to the IDC API.

## IDC Versions

As described previously, IDC data is versioned such that searching an IDC version according to some criteria (some _filter set_ as described below) will always identify exactly the same set of DICOM objects.

The _GET /versions API_ endpoint returns a list of the current and previous IDC data versions.

## Original Collections

An _original collection_ is a set of DICOM data provided by a single source. (We usually just use _collection_ to mean _original collection_.) Such _collections_ are comprised primarily of DICOM image data that was obtained from some set of patients. However some original collections also include annotations, segmentations or other analyses of the image data in the collection. Typically, the patients in an _collection_ are related by a common cancer type, though this is not always the case.

The _GET_ /collections endpoint returns a list of the _original collections,_ in the current IDC version. Some metadata about each collection is provided.

## Analysis Results

Analysis _results_ are comprised of DICOM data that was generated by analyzing data in one or more _original collections._ Typically such analysis is performed by a different entity than that which provided the _original_ _collection(s)_ on which the analysis is based. Examples of data in _analysis_ _collections_ include segmentations, annotations and further processing of original images.&#x20;

Because a DICOM instance in an _analysis result_ is "in" the same series and study as the DICOM instance data of which it is an analysis result, it is also "in" the same patient, and therefore is considered to be "in" the same collection.&#x20;

Specifically, each instance in IDC data has an associated _collection\_id._ An _analysis result_ will have the same _collection\_id_ as the _original collection_ of which it is an analysis result.&#x20;

The _GET_ /analysis\_results endpoint returns a list of the _analysis results, with some metadata,_ in the current IDC version.

## Filter Sets

Filters sets were previously introduced in [Exploring data and Cohorts](../portal/data-exploration-and-cohorts/). In this section we describe how filter sets are specified to the API.&#x20;

A _filter set_ selects some set of DICOM objects in IDC hosted data, and is a set of conditions, where each condition is defined by an **attribute** and an array of values. An attribute identifies a field (column) in some data source (BQ table). Each _filter set_ also includes the _IDC data version_ upon which it operates.

Filter sets are JSON encoded.  Here is an example _filter set_:

```
{
  "filters": {
    "collection_id": [
      "TCGA-LUAD",
      "TCGA-KIRC"
    ],
    "Modality": [
      "CT",
      "MR"
    ],
    "race": [
      "WHITE"
    ],
    "age_at_diagnosis_btw": [
      65, 
      75
    ]
  }
}
```

A _filter set_ selects a DICOM instance if, for every _attribute_ in the _filter set_, the instance's corresponding value _satisfies_ one or more of the values in the associated array of values. This is explained further below.

For example, the (attribute, \[values]) pair ("Modality", \["MR", "CT"]) is satisfied if an instance "has" a Modality of MR or CT.&#x20;

Note that if a _filter set_ includes more than one (attribute, \[values]) pair having the same attribute, then only the last such (attribute, \[values]) pair is used. Thus if a _filter group_ includes the (attribute, \[values]) pairs ("Modality", \["MR"]) and ("Modality", \["CT"]), in that order, only ("Modality", \["CT"]) is used.

The _filter set_ above will select any instance in the current IDC version that is in the TCGA\_KIRC collection or the TCGA\_LUAD' collections.  To be selected by the filter, an instance must also have a Modality of CT or MR, and an age\_at\_diagnosis value between 65 and 75 .&#x20;

Because of the hierarchical nature of DICOM, if a _filter set_ selects an instance, it implicitly selects the series, study, patient and collection which contain that instance. A manifest can be configured to return data about some or all of these entities.

Note that when defining a cohort through the API, the IDC version is always the current IDC version.&#x20;

## Data Sources

IDC maintains a set of GCP BigQuery (BQ) tables containing various types of metadata that together describe IDC data.

In the context of the API, a _data source_ (or just _source_) is a BQ table that contains some portion of the metadata against which a _filter set_ is applied. An API query to construct a manifest is performed against one or more such tables as needed.&#x20;

## Attributes

Both the IDC Web App and API expose selected fields against which queries can be performed. The _/filters_ endpoint returns the available filter attributes The _/filters/values/{filter}_ endpoint returns a list of the values which a specified Categorical String or Categorical Numeric filter attribute will match. Each _attribute_ has a data type, one of:

* **String:**\
  An _attribute_ with data type _**String**_ may have an arbitrary string value. For example, the possible values of a _StudyDescription_ attribute are arbitrary. An object is selected if its String attribute matches any of the values in the values array. Matching is insensitive to the case (upper case, lower case) of the characters in the strings. Thus ("StudyDescription",\["PETCT Skull-Thigh"] will match a StudyDescription containing the substring "PETCT SKULL-THIGH", or "petct skull-thigh" etc.\
  Pattern matching in String attributes is also supported. The ('StudyDescription",\["%SKULL%",  "ABDOMEN%", "%Pelvis"]) filter will match any StudyDescription that contains "SKULL", "skull", "Skull", etc., starts with "ABDOMEN", "abdomen", etc., or ends with "Pelvis", "PELVIS", etc.
* **Categorical String** An _attribute_ with data type Categorical String will have one of a defined set of string values. For example, Modality is an Categorical String _attribute_ that has possible values 'CT', 'MR', 'PT', etc.\
  Categorical String attributes have the same matching semantics as for Strings.\
  The /filters/values/{filter} endpoint returns a list of the values accepted for a specified Categorical String attribute (filter).
* **Categorical Numeric** An _attribute_ with data type Categorical Numeric has one of a defined set of numeric values. The corresponding value array must have a single numeric value. The (attribute, value array) pair for a Categorical Numeric is satisfied if the _attribute_ is equal to the value in the value array.\
  The /filters/values/{filter} endpoint returns a list of the values accepted for a Categorical Numeric attribute (filter).
*   **Ranged Integer** An attribute with data type Ranged Integer will have an integer value. For example, _age\_at\_diagnosis_ is an attribute of data type Ranged Integer. In order to enable relative numeric queries, the API exposes eight variations of each Ranged Integer attribute as _filter_ _attribute_ names. These variations are the base attribute name with one of the suffixes: _eq_, _gt_, _gte_, _btw_, _btwe_, _ebtw_, _ebtwe_, _lte_, or _lt,_ e.g. _age\_at\_diagnosis\_eq_. The value array of the _btw_, _btwe_, _ebtw_, and _ebtwe_ variations must contain exactly two **integer** values, in numeric order (least value first). The value array of the _eq_, _gt_, _gte_, _lte_, and _lt_ variations must contain exactly one **integer** values. The (attribute, value array) pair for a Ranged Integer attribute is satisfied according to the suffix as follows:

    * eq: If an _attribute_ is equal to the value in the value array
    * gt: If an _attribute_ is greater than the value in the value array
    * gte: If an _attribute_ is greater than or equal to the value in the value array
    * btw: if an _attribute_ is greater than the first value and less than the second value in the value array
    * ebtw: if an _attribute_ is greater than or equal to the first value and less than the second value in the value array
    * btwe: if an _attribute_ is greater than the first value and less than or equal to the second value in the value array
    * ebtwe: if an _attribute_ is greater than or equal to the first value and less than or equal to the second value in the value array
    * lte: If an _attribute_ is less than or equal to the value in the value array
    * lt: If an _attribute_ is less than the value in the value array

    **Ranged Number** An attribute with data type Ranged Number will have a numeric (integer or float) value. For example, _diameter_ is an attribute of data type Ranged Number. In order to enable relative numeric queries, the API exposes eight variations of each Ranged Number attribute as _filter_ _attribute_ names. These variations are the base _attribute_ name with one of the suffixes: _eq_, _gt_, _gte_, _btw_, _btwe_, _ebtw_, _ebtwe_, _lte_, or _lt,_ e.g. _diameter\_eq_. The value array of the _btw_, _btwe_, _ebtw_, and _ebtwe_ variations must contain exactly two numeric values, in numeric order (least value first). The value array of the _eq_, _gt_, _gte_, _lte_, and _lt_ variations must contain exactly one numeric values. The (attribute, value array) pair for a Ranged Number attribute is satisfied according to the suffix as follows:

    * eq: If an _attribute_ is equal to the value in the value array
    * gt: If an _attribute_ is greater than the value in the value array
    * gte: If an _attribute_ is greater than or equal to the value in the value array
    * btw: if an _attribute_ is greater than the first value and less than the second value in the value array
    * ebtw: if an _attribute_ is greater than or equal to the first value and less than the second value in the value array
    * btwe: if an _attribute_ is greater than the first value and less than or equal to the second value in the value array
    * ebtwe: if an _attribute_ is greater than or equal to the first value and less than or equal to the second value in the value array
    * lte: If an _attribute_ is less than or equal to the value in the value array
    * lt: If an _attribute_ is less than the value in the value array

## Cohorts

The API supports defining and saving cohorts, as well as accessing the user's previously saved cohorts, whether defined through the portal or the API. Through the API, the user can obtain  information about their previously defined cohorts, including the definition of each cohort in terms of a filter set and IDC version. The user can also obtain a manifest of the objects in the cohort. The data in the manifest is highly configurable and can be used, with suitable tools, to obtain DICOM files from cloud storage. A manifest returned by the API can include values from a large set of fields.

The _**POST /cohorts**_ API endpoint creates and saves a cohort as defined by a set of _filters_ and other cohort metadata. Here is an example JSON encoded cohort definition. :

<pre><code>{
<strong>  "name": "mycohort",
</strong>  "description": "Example description",
  "filters": {
    "collection_id": [
      "TCGA-LUAD",
      "TCGA-KIRC"
    ],
    "Modality": [
      "CT",
      "MR"
    ],
    "race": [
      "WHITE"
    ],
    "age_at_diagnosis_btw": [
      53, 69
    ]
  }
}
</code></pre>

&#x20;Note that the cohort definition does not include an _idc\_data\_version,_ because the cohort's version is implicitly the current IDC version when defining a new cohort.

The new cohort is saved under the IDC account of the caller of the API endpoint. The GET /cohorts API endpoint returns a list of the currently saved cohorts of the caller.&#x20;

The _**DELETE /cohorts/{cohort\_id}**_ endpoint deletes a cohort as specified by its _cohort\_id._ The _**DELETE /cohorts**_ API endpoint deletes zero or more cohorts as specified by a list of _cohort\_ids_. A user may only delete their own cohorts.

## **IDC API UI**

The [IDC API UI](https://api.imaging.datacommons.cancer.gov/v1/swagger) can be used to see details about the syntax for each call, and also provides an interface to test requests. Each endpoint is also documented the [Endpoint Details](endpoint-details.md) section.

## Authenticating to the UI

Some of the API calls require authentication. This is denoted by a small lock symbol. Authentication can be performed by clicking on the ‘Authorize’ button at the top right of the page.

## Make a Request

For a quick demonstration of the syntax of an API call, test the [GET /collections](https://api.imaging.datacommons.cancer.gov/v2/swagger#/data%20model/getCollections) request. You can experiment with this endpoint by clicking the ‘Try it out’ button, and then the 'Execute' button.

The API will return collection metadata for the current IDC data version.&#x20;

**Request Response**

The Swagger UI submits the request and shows the _**curl**_ code that was submitted. The _**Response body**_ section will display the response to the request. The expected JSON schema format of the response to this API request is shown below:

```
{
  "collections": [
    {
      "cancer_type": "string",
      "collection_id": "string",
      "date_updated": "string",
      "description": "string",
      "doi": "string",
      "image_types": "string",
      "location": "string",
      "species": "string",
      "subject_count": 0,
      "supporting_data": "string",
    }
  ],
  "code": 200
}
```

The actual JSON formatted response can be downloaded to your local file system by clicking the ‘Download’ button.
